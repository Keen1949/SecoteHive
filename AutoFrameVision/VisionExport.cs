//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 11.0
//

using HalconDotNet;
using AutoFrameVision;
public partial class HDevelopExport
{
#if !NO_EXPORT_APP_MAIN
  public HDevelopExport()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("width", 512);
    HOperatorSet.SetSystem("height", 512);
    action();
  }
#endif

    public void HDevelopStop()
    {
    }

    // Procedures 
    // External procedures 
    // Chapter: Matching / Shape-Based
    // Short Description: Display the results of Shape-Based Matching.
    public void dev_display_shape_matching_results(HTuple hv_ModelID, HTuple hv_Color,
        HTuple hv_Row, HTuple hv_Column, HTuple hv_Angle, HTuple hv_ScaleR, HTuple hv_ScaleC,
        HTuple hv_Model)
    {


        // Local iconic variables 

        HObject ho_ModelContours = null, ho_ContoursAffinTrans = null;


        // Local control variables 

        HTuple hv_NumMatches = null, hv_Index = new HTuple();
        HTuple hv_Match = new HTuple(), hv_HomMat2DIdentity = new HTuple();
        HTuple hv_HomMat2DScale = new HTuple(), hv_HomMat2DRotate = new HTuple();
        HTuple hv_HomMat2DTranslate = new HTuple();

        HTuple hv_Model_COPY_INP_TMP = hv_Model.Clone();
        HTuple hv_ScaleC_COPY_INP_TMP = hv_ScaleC.Clone();
        HTuple hv_ScaleR_COPY_INP_TMP = hv_ScaleR.Clone();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ModelContours);
        HOperatorSet.GenEmptyObj(out ho_ContoursAffinTrans);

        try
        {
            //This procedure displays the results of Shape-Based Matching.
            //
            hv_NumMatches = new HTuple(hv_Row.TupleLength());
            if ((int)(new HTuple(hv_NumMatches.TupleGreater(0))) != 0)
            {
                if ((int)(new HTuple((new HTuple(hv_ScaleR_COPY_INP_TMP.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    HOperatorSet.TupleGenConst(hv_NumMatches, hv_ScaleR_COPY_INP_TMP, out hv_ScaleR_COPY_INP_TMP);
                }
                if ((int)(new HTuple((new HTuple(hv_ScaleC_COPY_INP_TMP.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    HOperatorSet.TupleGenConst(hv_NumMatches, hv_ScaleC_COPY_INP_TMP, out hv_ScaleC_COPY_INP_TMP);
                }
                if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    HOperatorSet.TupleGenConst(hv_NumMatches, 0, out hv_Model_COPY_INP_TMP);
                }
                else if ((int)(new HTuple((new HTuple(hv_Model_COPY_INP_TMP.TupleLength()
                    )).TupleEqual(1))) != 0)
                {
                    HOperatorSet.TupleGenConst(hv_NumMatches, hv_Model_COPY_INP_TMP, out hv_Model_COPY_INP_TMP);
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ModelID.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    ho_ModelContours.Dispose();
                    HOperatorSet.GetShapeModelContours(out ho_ModelContours, hv_ModelID.TupleSelect(
                        hv_Index), 1);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
                            hv_Index % (new HTuple(hv_Color.TupleLength()))));
                    }
                    HTuple end_val18 = hv_NumMatches - 1;
                    HTuple step_val18 = 1;
                    for (hv_Match = 0; hv_Match.Continue(end_val18, step_val18); hv_Match = hv_Match.TupleAdd(step_val18))
                    {
                        if ((int)(new HTuple(hv_Index.TupleEqual(hv_Model_COPY_INP_TMP.TupleSelect(
                            hv_Match)))) != 0)
                        {
                            HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                            HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, hv_ScaleR_COPY_INP_TMP.TupleSelect(
                                hv_Match), hv_ScaleC_COPY_INP_TMP.TupleSelect(hv_Match), 0, 0,
                                out hv_HomMat2DScale);
                            HOperatorSet.HomMat2dRotate(hv_HomMat2DScale, hv_Angle.TupleSelect(
                                hv_Match), 0, 0, out hv_HomMat2DRotate);
                            HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_Row.TupleSelect(
                                hv_Match), hv_Column.TupleSelect(hv_Match), out hv_HomMat2DTranslate);
                            ho_ContoursAffinTrans.Dispose();
                            HOperatorSet.AffineTransContourXld(ho_ModelContours, out ho_ContoursAffinTrans,
                                hv_HomMat2DTranslate);
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContoursAffinTrans, HDevWindowStack.GetActive()
                                    );
                            }
                        }
                    }
                }
            }
            ho_ModelContours.Dispose();
            ho_ContoursAffinTrans.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ModelContours.Dispose();
            ho_ContoursAffinTrans.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Chapter: Graphics / Text
    // Short Description: This procedure writes a text message.
    public void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
        HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
    {


        // Local control variables 

        HTuple hv_Red = null, hv_Green = null, hv_Blue = null;
        HTuple hv_Row1Part = null, hv_Column1Part = null, hv_Row2Part = null;
        HTuple hv_Column2Part = null, hv_RowWin = null, hv_ColumnWin = null;
        HTuple hv_WidthWin = null, hv_HeightWin = null, hv_MaxAscent = null;
        HTuple hv_MaxDescent = null, hv_MaxWidth = null, hv_MaxHeight = null;
        HTuple hv_R1 = new HTuple(), hv_C1 = new HTuple(), hv_FactorRow = new HTuple();
        HTuple hv_FactorColumn = new HTuple(), hv_Width = new HTuple();
        HTuple hv_Index = new HTuple(), hv_Ascent = new HTuple();
        HTuple hv_Descent = new HTuple(), hv_W = new HTuple();
        HTuple hv_H = new HTuple(), hv_FrameHeight = new HTuple();
        HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
        HTuple hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
        HTuple hv_Exception = new HTuple(), hv_CurrentColor = new HTuple();

        HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
        HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
        HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();
        HTuple hv_String_COPY_INP_TMP = hv_String.Clone();

        // Initialize local and output iconic variables 

        //This procedure displays text in a graphics window.
        //
        //Input parameters:
        //WindowHandle: The WindowHandle of the graphics window, where
        //   the message should be displayed
        //String: A tuple of strings containing the text message to be displayed
        //CoordSystem: If set to 'window', the text position is given
        //   with respect to the window coordinate system.
        //   If set to 'image', image coordinates are used.
        //   (This may be useful in zoomed images.)
        //Row: The row coordinate of the desired text position
        //   If set to -1, a default value of 12 is used.
        //Column: The column coordinate of the desired text position
        //   If set to -1, a default value of 12 is used.
        //Color: defines the color of the text as string.
        //   If set to [], '' or 'auto' the currently set color is used.
        //   If a tuple of strings is passed, the colors are used cyclically
        //   for each new textline.
        //Box: If set to 'true', the text is written within a white box.
        //
        //prepare window
        HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
        HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part,
            out hv_Column2Part);
        HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin,
            out hv_WidthWin, out hv_HeightWin);
        HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin - 1, hv_WidthWin - 1);
        //
        //default settings
        if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Row_COPY_INP_TMP = 12;
        }
        if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Column_COPY_INP_TMP = 12;
        }
        if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
        {
            hv_Color_COPY_INP_TMP = "";
        }
        //
        hv_String_COPY_INP_TMP = ((("" + hv_String_COPY_INP_TMP) + "")).TupleSplit("\n");
        //
        //Estimate extentions of text depending on font size.
        HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent,
            out hv_MaxWidth, out hv_MaxHeight);
        if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
        {
            hv_R1 = hv_Row_COPY_INP_TMP.Clone();
            hv_C1 = hv_Column_COPY_INP_TMP.Clone();
        }
        else
        {
            //transform image to window coordinates
            hv_FactorRow = (1.0 * hv_HeightWin) / ((hv_Row2Part - hv_Row1Part) + 1);
            hv_FactorColumn = (1.0 * hv_WidthWin) / ((hv_Column2Part - hv_Column1Part) + 1);
            hv_R1 = ((hv_Row_COPY_INP_TMP - hv_Row1Part) + 0.5) * hv_FactorRow;
            hv_C1 = ((hv_Column_COPY_INP_TMP - hv_Column1Part) + 0.5) * hv_FactorColumn;
        }
        //
        //display text box depending on text size
        if ((int)(new HTuple(hv_Box.TupleEqual("true"))) != 0)
        {
            //calculate box extents
            hv_String_COPY_INP_TMP = (" " + hv_String_COPY_INP_TMP) + " ";
            hv_Width = new HTuple();
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                    hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
                hv_Width = hv_Width.TupleConcat(hv_W);
            }
            hv_FrameHeight = hv_MaxHeight * (new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                ));
            hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
            hv_R2 = hv_R1 + hv_FrameHeight;
            hv_C2 = hv_C1 + hv_FrameWidth;
            //display rectangles
            HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
            HOperatorSet.SetDraw(hv_WindowHandle, "fill");
            HOperatorSet.SetColor(hv_WindowHandle, "light gray");
            HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1 + 3, hv_C1 + 3, hv_R2 + 3, hv_C2 + 3);
            HOperatorSet.SetColor(hv_WindowHandle, "white");
            HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
            HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
        }
        else if ((int)(new HTuple(hv_Box.TupleNotEqual("false"))) != 0)
        {
            hv_Exception = "Wrong value of control parameter Box";
            throw new HalconException(hv_Exception);
        }
        //Write text.
        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
            )) - 1); hv_Index = (int)hv_Index + 1)
        {
            hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index % (new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                )));
            if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
                "auto")))) != 0)
            {
                HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
            }
            else
            {
                HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
            }
            hv_Row_COPY_INP_TMP = hv_R1 + (hv_MaxHeight * hv_Index);
            HOperatorSet.SetTposition(hv_WindowHandle, hv_Row_COPY_INP_TMP, hv_C1);
            HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                hv_Index));
        }
        //reset changed window settings
        HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
        HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part,
            hv_Column2Part);

        return;
    }

    // Chapter: XLD / Creation
    // Short Description: Creates an arrow shaped XLD contour.
    public void gen_arrow_contour_xld(out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
        HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
    {


        // Stack for temporary objects 
        HObject[] OTemp = new HObject[20];

        // Local iconic variables 

        HObject ho_TempArrow = null;


        // Local control variables 

        HTuple hv_Length = null, hv_ZeroLengthIndices = null;
        HTuple hv_DR = null, hv_DC = null, hv_HalfHeadWidth = null;
        HTuple hv_RowP1 = null, hv_ColP1 = null, hv_RowP2 = null;
        HTuple hv_ColP2 = null, hv_Index = null;

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Arrow);
        HOperatorSet.GenEmptyObj(out ho_TempArrow);

        try
        {
            //This procedure generates arrow shaped XLD contours,
            //pointing from (Row1, Column1) to (Row2, Column2).
            //If starting and end point are identical, a contour consisting
            //of a single point is returned.
            //
            //input parameteres:
            //Row1, Column1: Coordinates of the arrows' starting points
            //Row2, Column2: Coordinates of the arrows' end points
            //HeadLength, HeadWidth: Size of the arrow heads in pixels
            //
            //output parameter:
            //Arrow: The resulting XLD contour
            //
            //The input tuples Row1, Column1, Row2, and Column2 have to be of
            //the same length.
            //HeadLength and HeadWidth either have to be of the same length as
            //Row1, Column1, Row2, and Column2 or have to be a single element.
            //If one of the above restrictions is violated, an error will occur.
            //
            //
            //Init
            ho_Arrow.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            //
            //Calculate the arrow length
            HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
            //
            //Mark arrows with identical start and end point
            //(set Length to -1 to avoid division-by-zero exception)
            hv_ZeroLengthIndices = hv_Length.TupleFind(0);
            if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
            {
                if (hv_Length == null)
                    hv_Length = new HTuple();
                hv_Length[hv_ZeroLengthIndices] = -1;
            }
            //
            //Calculate auxiliary variables.
            hv_DR = (1.0 * (hv_Row2 - hv_Row1)) / hv_Length;
            hv_DC = (1.0 * (hv_Column2 - hv_Column1)) / hv_Length;
            hv_HalfHeadWidth = hv_HeadWidth / 2.0;
            //
            //Calculate end points of the arrow head.
            hv_RowP1 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) + (hv_HalfHeadWidth * hv_DC);
            hv_ColP1 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) - (hv_HalfHeadWidth * hv_DR);
            hv_RowP2 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) - (hv_HalfHeadWidth * hv_DC);
            hv_ColP2 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) + (hv_HalfHeadWidth * hv_DR);
            //
            //Finally create output XLD contour for each input point pair
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
            {
                if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
                {
                    //Create_ single points for arrows with identical start and end point
                    ho_TempArrow.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(
                        hv_Index), hv_Column1.TupleSelect(hv_Index));
                }
                else
                {
                    //Create arrow contour
                    ho_TempArrow.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
                        hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                        hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                        hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)),
                        ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
                        hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
                        hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
                        hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
                }
                HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out OTemp[0]);
                ho_Arrow.Dispose();
                ho_Arrow = OTemp[0];
            }
            ho_TempArrow.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_TempArrow.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 读取模板得到模板中心点和角度。
    public void InitTemplete(HTuple hv_WindowHandle, HTuple hv_Directory, out HTuple hv_ModelId, out HTuple hv_ModelData)
    {


        // Local iconic variables 

        HObject ho_ImageModel;


        // Local control variables 

        HTuple hv_ModelRow = null, hv_ModelScale = null;
        HTuple hv_ModelColumn = null, hv_ModelAngle = null, hv_ModelScore = null;

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_ImageModel);

        try
        {
            if (HDevWindowStack.IsOpen() && hv_WindowHandle == null)
            {
                hv_WindowHandle = HDevWindowStack.GetActive();
            }

            hv_ModelData = new HTuple();
            ho_ImageModel.Dispose();
            HOperatorSet.ReadImage(out ho_ImageModel, hv_Directory + "/Model.bmp");

            if (hv_WindowHandle != null)
            {
                HOperatorSet.DispObj(ho_ImageModel, hv_WindowHandle);
            }

            
            //tuple_length (WindowHandle, num)
            HOperatorSet.ReadShapeModel(hv_Directory + "/Model.shm", out hv_ModelId);

            //模板图片查找模板位置,不需要使用变形模板
            HOperatorSet.FindShapeModel(ho_ImageModel, hv_ModelId, (new HTuple(0)).TupleRad()
                , (new HTuple(360)).TupleRad(), 0.5, 1, 0.1, "none", (new HTuple(5)).TupleConcat(
                1), 0.75, out hv_ModelRow, out hv_ModelColumn, out hv_ModelAngle, out hv_ModelScore);
            //HOperatorSet.FindScaledShapeModel(ho_ImageModel, hv_ModelId, (new HTuple(-180)).TupleRad()
            //    , (new HTuple(180)).TupleRad(), 0.95, 1.05, 0.50, 1, 0.1, "least_squares",
            //     (new HTuple(5)).TupleConcat(1), 0.75, out hv_ModelRow, out hv_ModelColumn,
            //    out hv_ModelAngle, out hv_ModelScale, out hv_ModelScore);
            //Matching 01: transform the model contours into the detected positions
            if ((int)(new HTuple((new HTuple(hv_ModelScore.TupleLength())).TupleGreater(
                0))) != 0)
            {
                //存储模板位置信息
                HOperatorSet.TupleConcat(hv_ModelData, hv_ModelRow, out hv_ModelData);
                HOperatorSet.TupleConcat(hv_ModelData, hv_ModelColumn, out hv_ModelData);
                HOperatorSet.TupleConcat(hv_ModelData, hv_ModelAngle, out hv_ModelData);

                dev_display_shape_matching_results(hv_ModelId, "red", hv_ModelRow, hv_ModelColumn,
                    hv_ModelAngle, 1, 1, 0);
                dev_disp_message("Model Score is " + hv_ModelScore, "window", 20, 20, "green",
                    "false");
            }
            else
            {

                dev_disp_message("Model find fail !", "window", 20, 20, "red", "true");

            }
            ho_ImageModel.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_ImageModel.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 从ROI文件中读取旋转矩形参数
    public void ReadRoiRectangle2(HTuple hv_FileName, out HTuple hv_TupleData)
    {


        // Local iconic variables 


        // Local control variables 

        HTuple hv_FileHandle = null, hv_IsEOF = null;
        HTuple hv_x = null, hv_y = null, hv_strText = new HTuple();
        HTuple hv_strOp = new HTuple(), hv_strData = new HTuple();
        HTuple hv_len1 = new HTuple(), hv_len2 = new HTuple();
        HTuple hv_row = new HTuple(), hv_col = new HTuple(), hv_phi = new HTuple();

        // Initialize local and output iconic variables 

        try
        {

            HOperatorSet.OpenFile(hv_FileName, "input", out hv_FileHandle);
            hv_IsEOF = 0;
            hv_x = 0;
            hv_y = 10;
            hv_TupleData = new HTuple();
            while ((int)(new HTuple(hv_IsEOF.TupleEqual(0))) != 0)
            {
                HOperatorSet.FreadString(hv_FileHandle, out hv_strText, out hv_IsEOF);
                if ((int)(new HTuple(hv_strText.TupleEqual("<roi"))) != 0)
                {
                    while ((int)(new HTuple(hv_IsEOF.TupleEqual(0))) != 0)
                    {
                        HOperatorSet.FreadString(hv_FileHandle, out hv_strText, out hv_IsEOF);
                        //disp_message (Window, strText, 'window', x, y, 'red', 'false')
                        hv_x = hv_x + 15;
                        if ((int)(new HTuple(hv_strText.TupleEqual("<rect2"))) != 0)
                        {
                            HOperatorSet.FreadString(hv_FileHandle, out hv_strOp, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_strData, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_len1, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_len2, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_row, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_col, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_phi, out hv_IsEOF);
                            //disp_message (Window, strOp + len1+len2+row+col+phi, 'window', x, y, 'red', 'false')
                            hv_x = hv_x + 15;
                            HOperatorSet.TupleRegexpMatch(hv_row, "=\"(.*)\"", out hv_row);
                            HOperatorSet.TupleNumber(hv_row, out hv_row);
                            HOperatorSet.TupleRegexpMatch(hv_col, "=\"(.*)\"", out hv_col);
                            HOperatorSet.TupleNumber(hv_col, out hv_col);
                            HOperatorSet.TupleRegexpMatch(hv_phi, "=\"(.*)\"", out hv_phi);
                            HOperatorSet.TupleNumber(hv_phi, out hv_phi);
                            HOperatorSet.TupleRegexpMatch(hv_len1, "=\"(.*)\"", out hv_len1);
                            HOperatorSet.TupleNumber(hv_len1, out hv_len1);
                            HOperatorSet.TupleRegexpMatch(hv_len2, "=\"(.*)\"", out hv_len2);
                            HOperatorSet.TupleNumber(hv_len2, out hv_len2);

                            HOperatorSet.TupleConcat(hv_TupleData, hv_row, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_col, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_phi, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_len1, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_len2, out hv_TupleData);

                            //tuple_regexp_match (strOp, '="(.*)"', strOp)
                            //if (strOp == 'none')
                            //gen_rectangle2 (Region, row, col, rad(phi), len1, len2)
                            //else
                            //gen_rectangle2 (Rectangle2, row, col, rad(phi), len1, len2)
                            //if (strOp == 'union')
                            //union2 (Region, Rectangle2, Region)
                            //elseif (strOp == 'intersection')
                            //intersection (Region, Rectangle2, Region)
                            //elseif (strOp == 'difference')
                            //difference (Region, Rectangle2, Region)
                            //else
                            //disp_message (Window, strOp + 'not support!', 'window', x, y, 'red', 'false')
                            //x := x+15
                            //endif
                            //endif
                        }
                    }
                }
            }
            HOperatorSet.CloseFile(hv_FileHandle);

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 得到转换后的ROI数据。
    public void TranslateRoi(HTuple hv_FixTool, HTuple hv_TupleDataIn, out HTuple hv_TupleDataOut)
    {


        // Local iconic variables 


        // Local control variables 

        HTuple hv_Sx = null, hv_Sy = null, hv_Phi = null;
        HTuple hv_Theta = null, hv_Tx = null, hv_Ty = null, hv_Number = null;
        HTuple hv_row = new HTuple(), hv_col = new HTuple();

        // Initialize local and output iconic variables 

        try
        {
            HOperatorSet.HomMat2dToAffinePar(hv_FixTool, out hv_Sx, out hv_Sy, out hv_Phi,
                out hv_Theta, out hv_Tx, out hv_Ty);
            HOperatorSet.TupleLength(hv_TupleDataIn, out hv_Number);
            hv_TupleDataOut = new HTuple();
            //旋转矩形
            if ((int)(new HTuple(hv_Number.TupleEqual(5))) != 0)
            {
                HOperatorSet.AffineTransPoint2d(hv_FixTool, hv_TupleDataIn.TupleSelect(0),
                    hv_TupleDataIn.TupleSelect(1), out hv_row, out hv_col);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[0] = hv_row;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[1] = hv_col;
                //加上模板查找的角度并转换为弧角度
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[2] = (((hv_TupleDataIn.TupleSelect(2))).TupleRad()) + hv_Phi;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[3] = hv_TupleDataIn.TupleSelect(3);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[4] = hv_TupleDataIn.TupleSelect(4);
                //gen_rectangle2 (Rectangle, TupleDataOut[0], TupleDataOut[1], TupleDataOut[2], TupleDataOut[3], TupleDataOut[4])

                //圆环
            }
            else if ((int)(new HTuple(hv_Number.TupleEqual(6))) != 0)
            {
                HOperatorSet.AffineTransPoint2d(hv_FixTool, hv_TupleDataIn.TupleSelect(0),
                    hv_TupleDataIn.TupleSelect(1), out hv_row, out hv_col);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[0] = hv_row;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[1] = hv_col;
                //圆没有角度
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[2] = hv_TupleDataIn.TupleSelect(2);
                HOperatorSet.AffineTransPoint2d(hv_FixTool, hv_TupleDataIn.TupleSelect(3),
                    hv_TupleDataIn.TupleSelect(4), out hv_row, out hv_col);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[3] = hv_row;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[4] = hv_col;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[5] = hv_TupleDataIn.TupleSelect(5);
                //圆弧环
            }
            else if ((int)(new HTuple(hv_Number.TupleEqual(10))) != 0)
            {
                hv_TupleDataOut = hv_TupleDataIn.Clone();
                HOperatorSet.AffineTransPoint2d(hv_FixTool, hv_TupleDataIn.TupleSelect(0),
                    hv_TupleDataIn.TupleSelect(1), out hv_row, out hv_col);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[0] = hv_row;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[1] = hv_col;
                //圆弧需要计算起始角度
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[3] = (((hv_TupleDataIn.TupleSelect(3))).TupleRad()) + hv_Phi;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[4] = ((hv_TupleDataIn.TupleSelect(4))).TupleRad();

                HOperatorSet.AffineTransPoint2d(hv_FixTool, hv_TupleDataIn.TupleSelect(5),
                    hv_TupleDataIn.TupleSelect(6), out hv_row, out hv_col);
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[5] = hv_row;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[6] = hv_col;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[8] = (((hv_TupleDataIn.TupleSelect(8))).TupleRad()) + hv_Phi;
                if (hv_TupleDataOut == null)
                    hv_TupleDataOut = new HTuple();
                hv_TupleDataOut[9] = ((hv_TupleDataIn.TupleSelect(9))).TupleRad();
                //不支持的格式
            }
            else
            {

            }




            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 通过输入参数寻找区域当中的直线
    public void FindLine(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_TupleRectangle2, HTuple hv_NumPoints,
        HTuple hv_RectWidth, HTuple hv_NumDropPoints, HTuple hv_AmpThreshold, HTuple hv_Smooth,
        HTuple hv_Transition, HTuple hv_Select, out HTuple hv_RowBegin, out HTuple hv_ColBegin,
        out HTuple hv_RowEnd, out HTuple hv_ColEnd)
    {


        // Initialize local and output iconic variables 

        //解析ROI数据,转入查找直线函数
        FindLine_Rectangle2(hv_WindowHandle,ho_Image, hv_TupleRectangle2.TupleSelect(0), hv_TupleRectangle2.TupleSelect(
            1), hv_TupleRectangle2.TupleSelect(2), hv_TupleRectangle2.TupleSelect(3),
            hv_TupleRectangle2.TupleSelect(4), hv_NumPoints, hv_RectWidth, hv_NumDropPoints,
            hv_AmpThreshold, hv_Smooth, hv_Transition, hv_Select, out hv_RowBegin, out hv_ColBegin,
            out hv_RowEnd, out hv_ColEnd);
    }

    // Short Description: 读取圆roi的中心坐标以及半径。
    public void ReadRoiAnnularCircle(HTuple hv_FileName, out HTuple hv_TupleData)
    {


        // Local iconic variables 


        // Local control variables 

        HTuple hv_FileHandle = null, hv_IsEOF = null;
        HTuple hv_x = null, hv_y = null, hv_strText = new HTuple();
        HTuple hv_strOp = new HTuple(), hv_strData = new HTuple();
        HTuple hv_row = new HTuple(), hv_radius = new HTuple();
        HTuple hv_col = new HTuple();
        HTuple hv_startphi = new HTuple(), hv_extentphi = new HTuple();

        // Initialize local and output iconic variables 

        try
        {

            HOperatorSet.OpenFile(hv_FileName, "input", out hv_FileHandle);
            hv_IsEOF = 0;
            hv_x = 0;
            hv_y = 0;
            hv_TupleData = new HTuple();
            while ((int)(new HTuple(hv_IsEOF.TupleEqual(0))) != 0)
            {
                HOperatorSet.FreadString(hv_FileHandle, out hv_strText, out hv_IsEOF);
                //判断是否是ROI区
                if ((int)(new HTuple(hv_strText.TupleEqual("<roi"))) != 0)
                {
                    while ((int)(new HTuple(hv_IsEOF.TupleEqual(0))) != 0)
                    {
                        HOperatorSet.FreadString(hv_FileHandle, out hv_strText, out hv_IsEOF);
                        //disp_message (Window, strText, 'window', x, y, 'red', 'false')
                        //x := x+15
                        //判断是否是圆
                        if ((int)(new HTuple(hv_strText.TupleEqual("<circle"))) != 0)
                        {
                            HOperatorSet.FreadString(hv_FileHandle, out hv_strOp, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_strData, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_row, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_radius, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_col, out hv_IsEOF);
                            //disp_message (Window, strOp + row+radius+col, 'window', x, y, 'red', 'false')
                            //x := x+15
                            HOperatorSet.TupleRegexpMatch(hv_row, "=\"(.*)\"", out hv_row);
                            HOperatorSet.TupleNumber(hv_row, out hv_row);
                            HOperatorSet.TupleRegexpMatch(hv_col, "=\"(.*)\"", out hv_col);
                            HOperatorSet.TupleNumber(hv_col, out hv_col);
                            HOperatorSet.TupleRegexpMatch(hv_radius, "=\"(.*)\"", out hv_radius);
                            HOperatorSet.TupleNumber(hv_radius, out hv_radius);

                            HOperatorSet.TupleRegexpMatch(hv_strOp, "=\"(.*)\"", out hv_strOp);

                            HOperatorSet.TupleConcat(hv_TupleData, hv_row, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_col, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_radius, out hv_TupleData);                          
                        }
                        else if ((int)(new HTuple(hv_strText.TupleEqual("<circ_arc"))) != 0)
                        {
                            HOperatorSet.FreadString(hv_FileHandle, out hv_strOp, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_strData, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_row, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_radius, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_extentphi, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_startphi, out hv_IsEOF);
                            HOperatorSet.FreadString(hv_FileHandle, out hv_col, out hv_IsEOF);
                            //disp_message (Window, strOp + row+radius+col, 'window', x, y, 'red', 'false')
                            //x := x+15
                            HOperatorSet.TupleRegexpMatch(hv_row, "=\"(.*)\"", out hv_row);
                            HOperatorSet.TupleNumber(hv_row, out hv_row);
                            HOperatorSet.TupleRegexpMatch(hv_col, "=\"(.*)\"", out hv_col);
                            HOperatorSet.TupleNumber(hv_col, out hv_col);
                            HOperatorSet.TupleRegexpMatch(hv_radius, "=\"(.*)\"", out hv_radius);
                            HOperatorSet.TupleNumber(hv_radius, out hv_radius);

                            HOperatorSet.TupleRegexpMatch(hv_extentphi, "=\"(.*)\"", out hv_extentphi);
                            HOperatorSet.TupleNumber(hv_extentphi, out hv_extentphi);
                            HOperatorSet.TupleRegexpMatch(hv_startphi, "=\"(.*)\"", out hv_startphi);
                            HOperatorSet.TupleNumber(hv_startphi, out hv_startphi);

                            HOperatorSet.TupleRegexpMatch(hv_strOp, "=\"(.*)\"", out hv_strOp);

                            HOperatorSet.TupleConcat(hv_TupleData, hv_row, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_col, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_radius, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_startphi, out hv_TupleData);
                            HOperatorSet.TupleConcat(hv_TupleData, hv_extentphi, out hv_TupleData);
                        }
                    }
                }
            }
            HOperatorSet.CloseFile(hv_FileHandle);

            return;



        }
        catch (HalconException HDevExpDefaultException)
        {

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 通过输入带角度的矩形框寻找中间的直线
    public void FindLine_Rectangle2(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_Row, HTuple hv_Col,
        HTuple hv_Phi, HTuple hv_Len1, HTuple hv_Len2, HTuple hv_NumPoints, HTuple hv_RectWidth,
        HTuple hv_NumDropPoints, HTuple hv_AmpThreshold, HTuple hv_Smooth, HTuple hv_Transition,
        HTuple hv_Select, out HTuple hv_RowBegin, out HTuple hv_ColBegin, out HTuple hv_RowEnd,
        out HTuple hv_ColEnd)
    {



        // Local iconic variables 

        HObject ho_cross = null, ho_Contour = null, ho_Line = null;


        // Local control variables 

        HTuple hv_imgWidth = null, hv_imgHeight = null;
        HTuple hv_Rect_Row = null, hv_Rect_Col = null, hv_RowOut = null;
        HTuple hv_ColOut = null, hv_Rect_offset = null, hv_Phi_Tmp = null;
        HTuple hv_Rect_Phi = null, hv_Rect_Len1 = null, hv_Rect_Len2 = null;
        HTuple hv_HomMat2DIdentity = null, hv_HomMat2DTranslate = null;
        HTuple hv_MsrHandle = null, hv_Index = null;
        HTuple hv_RowMeasure = new HTuple(), hv_num = new HTuple();
        HTuple hv_ColMeasure = new HTuple(), hv_Nr = new HTuple();
        HTuple hv_Nc = new HTuple(), hv_Dist = new HTuple(), hv_rowLine = new HTuple();
        HTuple hv_colLine = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_cross);
        HOperatorSet.GenEmptyObj(out ho_Contour);
        HOperatorSet.GenEmptyObj(out ho_Line);

        hv_RowBegin = new HTuple();
        hv_ColBegin = new HTuple();
        hv_RowEnd = new HTuple();
        hv_ColEnd = new HTuple();
        try
        {


            HOperatorSet.GetImageSize(ho_Image, out hv_imgWidth, out hv_imgHeight);

            hv_Rect_Row = new HTuple();
            hv_Rect_Col = new HTuple();
            hv_RowOut = new HTuple();
            hv_ColOut = new HTuple();

            if (hv_WindowHandle == null && HDevWindowStack.IsOpen())
            {
                hv_WindowHandle = HDevWindowStack.GetActive();
            }

            //计算量测小矩形的座标位置及角度
            hv_Rect_offset = hv_Len1 / hv_NumPoints;
            hv_Phi_Tmp = hv_Phi + ((new HTuple(90)).TupleRad());
            hv_Rect_Row = (hv_Row + (hv_Len2 * (hv_Phi_Tmp.TupleSin()))) - ((hv_Rect_offset * (hv_Phi_Tmp.TupleSin()
                )) / 2);
            hv_Rect_Col = (hv_Col - (hv_Len2 * (hv_Phi_Tmp.TupleCos()))) + ((hv_Rect_offset * (hv_Phi_Tmp.TupleCos()
                )) / 2);
            hv_Rect_Phi = hv_Phi.Clone();
            hv_Rect_Len1 = hv_Len1.Clone();
            hv_Rect_Len2 = hv_RectWidth / 2;

            HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
            HOperatorSet.HomMat2dTranslate(hv_HomMat2DIdentity, (((-hv_Len2) * 2) * (hv_Phi_Tmp.TupleSin()
                )) / hv_NumPoints, ((hv_Len2 * (hv_Phi_Tmp.TupleCos())) * 2) / hv_NumPoints, out hv_HomMat2DTranslate);
            HOperatorSet.GenMeasureRectangle2(hv_Rect_Row, hv_Rect_Col, hv_Rect_Phi, hv_Rect_Len1,
                hv_Rect_Len2, hv_imgWidth, hv_imgHeight, "nearest_neighbor", out hv_MsrHandle);

            HTuple end_val22 = hv_NumPoints - 1;
            HTuple step_val22 = 1;
            for (hv_Index = 0; hv_Index.Continue(end_val22, step_val22); hv_Index = hv_Index.TupleAdd(step_val22))
            {
                //显示当前的量测矩形区域
                if ((int)(0) != 0)
                {
                    if (hv_WindowHandle != null)
                    {
                        HOperatorSet.SetColor(hv_WindowHandle, "green");
                        HOperatorSet.SetDraw(hv_WindowHandle, "margin");

                        HOperatorSet.DispRectangle2(hv_WindowHandle, hv_Rect_Row, hv_Rect_Col,
                            hv_Rect_Phi, hv_Rect_Len1, hv_Rect_Len2);
                    }
                    
                }
                //查找边缘点
                FindPoint(ho_Image, hv_MsrHandle, hv_Smooth, hv_AmpThreshold, hv_Transition,
                    hv_Select, out hv_RowMeasure, out hv_ColMeasure);
                HOperatorSet.TupleLength(hv_RowMeasure, out hv_num);
                if ((int)(new HTuple(hv_num.TupleGreater(0))) != 0)
                {
                    HOperatorSet.TupleConcat(hv_RowOut, hv_RowMeasure, out hv_RowOut);
                    HOperatorSet.TupleConcat(hv_ColOut, hv_ColMeasure, out hv_ColOut);
                }
                //旋转及平移量测区区域
                HOperatorSet.AffineTransPixel(hv_HomMat2DTranslate, hv_Rect_Row, hv_Rect_Col,
                    out hv_Rect_Row, out hv_Rect_Col);
                HOperatorSet.TranslateMeasure(hv_MsrHandle, hv_Rect_Row, hv_Rect_Col);
            }
            HOperatorSet.CloseMeasure(hv_MsrHandle);

            //要求获取到的最终的边缘点大于总点数的一半
            if ((int)(new HTuple((new HTuple(hv_RowOut.TupleLength())).TupleGreater(hv_NumPoints / 10))) != 0)
            {
                //绘制每个边缘点
                if ((int)(1) != 0)
                {
                    if (hv_WindowHandle != null)
                    {
                        HOperatorSet.SetColor(hv_WindowHandle, "blue");
                        ho_cross.Dispose();
                        HOperatorSet.GenCrossContourXld(out ho_cross, hv_RowOut, hv_ColOut, 10,
                            0.785398);

                        HOperatorSet.DispObj(ho_cross, hv_WindowHandle);
                    }
                }


                ho_Contour.Dispose();
                HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_RowOut, hv_ColOut);
                HOperatorSet.FitLineContourXld(ho_Contour, "tukey", hv_NumPoints * 0.9, 0,
                    15, 5, out hv_RowBegin, out hv_ColBegin, out hv_RowEnd, out hv_ColEnd,
                    out hv_Nr, out hv_Nc, out hv_Dist);
                //显示查找到的直线
                if ((int)(1) != 0)
                {
                    if (hv_WindowHandle != null)
                    {
                        HOperatorSet.SetColor(hv_WindowHandle, "red");
                    }
                    

                    hv_rowLine = new HTuple();
                    hv_colLine = new HTuple();
                    HOperatorSet.TupleConcat(hv_rowLine, hv_RowBegin, out hv_rowLine);
                    HOperatorSet.TupleConcat(hv_rowLine, hv_RowEnd, out hv_rowLine);
                    HOperatorSet.TupleConcat(hv_colLine, hv_ColBegin, out hv_colLine);
                    HOperatorSet.TupleConcat(hv_colLine, hv_ColEnd, out hv_colLine);
                    ho_Line.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_Line, hv_rowLine, hv_colLine);

                    if (hv_WindowHandle != null)
                    {
                        HOperatorSet.DispObj(ho_Line, hv_WindowHandle);
                    }
                    
                }
            }
            else
            {
                hv_RowBegin = new HTuple();
                hv_ColBegin = new HTuple();
                hv_RowEnd = new HTuple();
                hv_ColEnd = new HTuple();
            }
            ho_cross.Dispose();
            ho_Contour.Dispose();
            ho_Line.Dispose();

            return;


        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_cross.Dispose();
            ho_Contour.Dispose();
            ho_Line.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void FindCircle_Circle(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_RowCircle, HTuple hv_ColCircle,
        HTuple hv_RadiusCircle, HTuple hv_Length, HTuple hv_PhiStart, HTuple hv_PhiExtent,
        HTuple hv_NumPoints, HTuple hv_NumDropPoints, HTuple hv_AmpThreshold, HTuple hv_Smooth,
        HTuple hv_Transition, HTuple hv_Select, out HTuple hv_Row, out HTuple hv_Col,
        out HTuple hv_Radius)
    {



        // Local iconic variables 

        HObject ho_cross = null, ho_Contour = null, ho_Circle = null;


        // Local control variables 

        HTuple hv_imgWidth = null, hv_imgHeight = null;
        HTuple hv_RowOut = null, hv_ColOut = null, hv_Row_Rect = null;
        HTuple hv_Col_Rect = null, hv_Angle = null, hv_RoiWidth = null;
        HTuple hv_direction = new HTuple();
        HTuple hv_HomMat2DIdentity = null, hv_HomMat2DRotate = null;
        HTuple hv_Index = null, hv_MsrHandle = new HTuple(), hv_RowMeasure = new HTuple();
        HTuple hv_num = new HTuple(), hv_ColMeasure = new HTuple();
        HTuple hv_StartPhi = new HTuple(), hv_EndPhi = new HTuple();
        HTuple hv_PointOrder = new HTuple();

        HTuple hv_Length_COPY_INP_TMP = hv_Length.Clone();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_cross);
        HOperatorSet.GenEmptyObj(out ho_Contour);
        HOperatorSet.GenEmptyObj(out ho_Circle);

        hv_Row = new HTuple();
        hv_Col = new HTuple();
        hv_Radius = new HTuple();
        try
        {

            HOperatorSet.GetImageSize(ho_Image, out hv_imgWidth, out hv_imgHeight);
            hv_RowOut = new HTuple();
            hv_ColOut = new HTuple();

            //分割矩形的中心坐标
            hv_Row_Rect = hv_RowCircle - ((hv_PhiStart.TupleSin()) * (hv_RadiusCircle + (hv_Length_COPY_INP_TMP / 2)));
            hv_Col_Rect = hv_ColCircle + ((hv_PhiStart.TupleCos()) * (hv_RadiusCircle + (hv_Length_COPY_INP_TMP / 2)));

            //分割角度
            hv_Angle = hv_PhiExtent / hv_NumPoints;
            hv_RoiWidth = ((hv_Angle.TupleSin()) * (hv_RadiusCircle + (hv_Length_COPY_INP_TMP / 2))) / 2;

            //显示整体的ROI区域
            if (hv_WindowHandle == null && HDevWindowStack.IsOpen())
            {
                hv_WindowHandle = HDevWindowStack.GetActive();
            }

            //disp_circle (WindowHandle, RowCircle, ColCircle, RadiusCircle)
            //disp_circle (WindowHandle, RowCircle, ColCircle, RadiusCircle + Length)

            if ((int)(new HTuple(hv_Length_COPY_INP_TMP.TupleGreater(0))) != 0)
            {
                //由内向外
                hv_direction = 0;
            }
            else
            {
                //由外向内
                hv_direction = (new HTuple(180)).TupleRad();
                hv_Length_COPY_INP_TMP = -hv_Length_COPY_INP_TMP;
            }

            HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
            HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, hv_Angle, hv_RowCircle, hv_ColCircle,
                out hv_HomMat2DRotate);
            HTuple end_val29 = hv_NumPoints - 1;
            HTuple step_val29 = 1;
            for (hv_Index = 0; hv_Index.Continue(end_val29, step_val29); hv_Index = hv_Index.TupleAdd(step_val29))
            {
                //显示当前查找边缘的ROI区
                if ((int)(0) != 0)
                {
                    if (hv_WindowHandle != null)
                    {
                        HOperatorSet.SetColor(hv_WindowHandle, "green");

                        HOperatorSet.SetDraw(hv_WindowHandle, "margin");

                        HOperatorSet.DispRectangle2(hv_WindowHandle, hv_Row_Rect, hv_Col_Rect,
                            (hv_PhiStart + (hv_Index * hv_Angle)) + hv_direction, hv_Length_COPY_INP_TMP / 2,
                            hv_RoiWidth);
                    }
                   
                }

                HOperatorSet.GenMeasureRectangle2(hv_Row_Rect, hv_Col_Rect, (hv_PhiStart + (hv_Index * hv_Angle)) + hv_direction,
                    hv_Length_COPY_INP_TMP / 2, hv_RoiWidth, hv_imgWidth, hv_imgHeight, "nearest_neighbor",
                    out hv_MsrHandle);
                hv_RowMeasure = new HTuple();
                //查找边缘点
                FindPoint(ho_Image, hv_MsrHandle, hv_Smooth, hv_AmpThreshold, hv_Transition,
                    hv_Select, out hv_RowMeasure, out hv_ColMeasure);
                HOperatorSet.TupleLength(hv_RowMeasure, out hv_num);
                if ((int)(new HTuple(hv_num.TupleGreater(0))) != 0)
                {
                    HOperatorSet.TupleConcat(hv_RowOut, hv_RowMeasure, out hv_RowOut);
                    HOperatorSet.TupleConcat(hv_ColOut, hv_ColMeasure, out hv_ColOut);
                }
                HOperatorSet.CloseMeasure(hv_MsrHandle);
                //旋转量测区域中心点
                HOperatorSet.AffineTransPixel(hv_HomMat2DRotate, hv_Row_Rect, hv_Col_Rect,
                    out hv_Row_Rect, out hv_Col_Rect);
            }
            //要求获取到的最终的边缘点大于总点数的一半
            if ((int)(new HTuple((new HTuple(hv_RowOut.TupleLength())).TupleGreater(hv_NumPoints / 2))) != 0)
            {
                //显示所有找到的边缘点
                if ((int)(1) != 0)
                {
                    if (hv_WindowHandle != null)
                    {
                        HOperatorSet.SetColor(hv_WindowHandle, "blue");

                        ho_cross.Dispose();
                        HOperatorSet.GenCrossContourXld(out ho_cross, hv_RowOut, hv_ColOut, 15,
                            0.785398);

                        HOperatorSet.DispObj(ho_cross, hv_WindowHandle);
                    }
                }

                ho_Contour.Dispose();
                HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_RowOut, hv_ColOut);
                HOperatorSet.FitCircleContourXld(ho_Contour, "atukey", hv_NumPoints - hv_NumDropPoints,
                    0, 0, 15, 6, out hv_Row, out hv_Col, out hv_Radius, out hv_StartPhi,
                    out hv_EndPhi, out hv_PointOrder);
                //显示找到的圆弧
                if ((int)(1) != 0)
                {
                    if (hv_WindowHandle != null)
                    {
                        HOperatorSet.SetColor(hv_WindowHandle, "red");

                        ho_Circle.Dispose();
                        HOperatorSet.GenCircleContourXld(out ho_Circle, hv_Row, hv_Col, hv_Radius,
                            hv_StartPhi, hv_EndPhi, hv_PointOrder, 1);

                        HOperatorSet.DispObj(ho_Circle, hv_WindowHandle);
                    }
                    
                }
            }
            else
            {
                hv_Row = new HTuple();
                hv_Col = new HTuple();
                hv_Radius = new HTuple();
            }
            ho_cross.Dispose();
            ho_Contour.Dispose();
            ho_Circle.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_cross.Dispose();
            ho_Contour.Dispose();
            ho_Circle.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 通过两个圆环或者圆弧环寻找中间的圆
    public void FindCircle(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_TupleAnnular, HTuple hv_Direction,
        HTuple hv_NumPoints, HTuple hv_NumDropPoints, HTuple hv_AmpThreshold, HTuple hv_Smooth,
        HTuple hv_Transition, HTuple hv_Select, out HTuple hv_Row, out HTuple hv_Col,
        out HTuple hv_Radius)
    {



        // Local control variables 

        HTuple hv_RowCircle = new HTuple(), hv_ColCircle = new HTuple();
        HTuple hv_RadiusCircle = new HTuple(), hv_Length = new HTuple();
        HTuple hv_PhiStart = new HTuple(), hv_PhiExtent = new HTuple();

        // Initialize local and output iconic variables 

        hv_Row = new HTuple();
        hv_Col = new HTuple();
        hv_Radius = new HTuple();

        //解析圆数据,根据长度判断是圆环还是圆弧环
        if ((int)(new HTuple((new HTuple(hv_TupleAnnular.TupleLength())).TupleEqual(6))) != 0)
        {
            //由内向外时,中心点和半径以小圆为基准, 长度值为正值
            if ((int)(new HTuple(hv_Direction.TupleEqual("inner"))) != 0)
            {
                if ((int)(new HTuple(((hv_TupleAnnular.TupleSelect(2))).TupleLess(hv_TupleAnnular.TupleSelect(
                    5)))) != 0)
                {
                    hv_RowCircle = hv_TupleAnnular[0];
                    hv_ColCircle = hv_TupleAnnular[1];
                    hv_RadiusCircle = hv_TupleAnnular[2];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(5)) - (hv_TupleAnnular.TupleSelect(
                        2));
                }
                else
                {
                    hv_RowCircle = hv_TupleAnnular[3];
                    hv_ColCircle = hv_TupleAnnular[4];
                    hv_RadiusCircle = hv_TupleAnnular[5];
                    hv_Length = (hv_TupleAnnular.TupleSelect(2)) - (hv_TupleAnnular.TupleSelect(
                        5));
                }
                //由外向内时,中心点和半径以大圆为基准, 长度值为负值
            }
            else
            {
                if ((int)(new HTuple(((hv_TupleAnnular.TupleSelect(2))).TupleLess(hv_TupleAnnular.TupleSelect(
                    5)))) != 0)
                {
                    hv_RowCircle = hv_TupleAnnular[3];
                    hv_ColCircle = hv_TupleAnnular[4];
                    hv_RadiusCircle = hv_TupleAnnular[5];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(2)) - (hv_TupleAnnular.TupleSelect(
                        5));
                }
                else
                {
                    hv_RowCircle = hv_TupleAnnular[0];
                    hv_ColCircle = hv_TupleAnnular[1];
                    hv_RadiusCircle = hv_TupleAnnular[2];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(5)) - (hv_TupleAnnular.TupleSelect(
                        2));
                }
            }
            //起始角度0,结束角度360
            FindCircle_Circle(hv_WindowHandle,ho_Image, hv_RowCircle, hv_ColCircle, hv_RadiusCircle, hv_Length,
                (new HTuple(0)).TupleRad(), (new HTuple(360)).TupleRad(), hv_NumPoints,
                hv_NumDropPoints, hv_AmpThreshold, hv_Smooth, hv_Transition, hv_Select,
                out hv_Row, out hv_Col, out hv_Radius);
        }
        else if ((int)(new HTuple((new HTuple(hv_TupleAnnular.TupleLength())).TupleEqual(
            10))) != 0)
        {
            //由内向外时,中心点和半径以小圆为基准, 长度值为正值
            if ((int)(new HTuple(hv_Direction.TupleEqual("inner"))) != 0)
            {
                if ((int)(new HTuple(((hv_TupleAnnular.TupleSelect(2))).TupleLess(hv_TupleAnnular.TupleSelect(
                    7)))) != 0)
                {
                    hv_RowCircle = hv_TupleAnnular[0];
                    hv_ColCircle = hv_TupleAnnular[1];
                    hv_RadiusCircle = hv_TupleAnnular[2];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(7)) - (hv_TupleAnnular.TupleSelect(
                        2));
                    hv_PhiStart = hv_TupleAnnular[3];
                    hv_PhiExtent = hv_TupleAnnular[4];
                }
                else
                {
                    hv_RowCircle = hv_TupleAnnular[5];
                    hv_ColCircle = hv_TupleAnnular[6];
                    hv_RadiusCircle = hv_TupleAnnular[7];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(2)) - (hv_TupleAnnular.TupleSelect(
                        7));
                    hv_PhiStart = hv_TupleAnnular[8];
                    hv_PhiExtent = hv_TupleAnnular[9];
                }
                //由外向内时,中心点和半径以大圆为基准, 长度值为负值
            }
            else
            {
                if ((int)(new HTuple(((hv_TupleAnnular.TupleSelect(2))).TupleLess(hv_TupleAnnular.TupleSelect(
                    7)))) != 0)
                {
                    hv_RowCircle = hv_TupleAnnular[5];
                    hv_ColCircle = hv_TupleAnnular[6];
                    hv_RadiusCircle = hv_TupleAnnular[7];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(2)) - (hv_TupleAnnular.TupleSelect(
                        7));
                    hv_PhiStart = hv_TupleAnnular[8];
                    hv_PhiExtent = hv_TupleAnnular[9];
                }
                else
                {
                    hv_RowCircle = hv_TupleAnnular[0];
                    hv_ColCircle = hv_TupleAnnular[1];
                    hv_RadiusCircle = hv_TupleAnnular[2];
                    //大小圆相减,得到查找长度范围
                    hv_Length = (hv_TupleAnnular.TupleSelect(7)) - (hv_TupleAnnular.TupleSelect(
                        2));
                    hv_PhiStart = hv_TupleAnnular[3];
                    hv_PhiExtent = hv_TupleAnnular[4];
                }
            }
            FindCircle_Circle(hv_WindowHandle,ho_Image, hv_RowCircle, hv_ColCircle, hv_RadiusCircle, hv_Length,
                hv_PhiStart, hv_PhiExtent, hv_NumPoints, hv_NumDropPoints, hv_AmpThreshold,
                hv_Smooth, hv_Transition, hv_Select, out hv_Row, out hv_Col, out hv_Radius);

        }


        return;
    }

    // Short Description: 寻找制定图像区域的边缘点。
    public void FindPoint(HObject ho_Image, HTuple hv_MsrHandle, HTuple hv_Smooth,
        HTuple hv_AmpThreshold, HTuple hv_Transition, HTuple hv_Select, out HTuple hv_Row,
        out HTuple hv_Col)
    {


        HSystem sys = new HSystem();

        // Local control variables 

        HTuple hv_Amplitude_Measure = new HTuple();
        HTuple hv_Distance_Measure = new HTuple(), hv_Row_Measure = new HTuple();
        HTuple hv_Col_Measure = new HTuple(), hv_num = new HTuple();
        HTuple hv_Indices = new HTuple(), hv_index = new HTuple();
        HTuple hv_Exception = new HTuple();

        // Initialize local and output iconic variables 

        hv_Row = new HTuple();
        hv_Col = new HTuple();
        // (dev_)set_check ("~give_error")
        try
        {


            //取第一点或最后一点时,直接调用
            if ((int)((new HTuple(hv_Select.TupleEqual("first"))).TupleOr(new HTuple(hv_Select.TupleEqual(
                "last")))) != 0)
            {
                try
                {
                    HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle, hv_Smooth, hv_AmpThreshold,
              hv_Transition, hv_Select, out hv_Row, out hv_Col, out hv_Amplitude_Measure,
              out hv_Distance_Measure);
                }
                catch (HalconException e)
                {
                    int error = e.GetErrorNumber();
                    if (error < 0)
                        throw e;
                }
            }
            else if ((int)(new HTuple(hv_Select.TupleEqual("strongest"))) != 0)
            {
                //取最强点是,需要全部查找出来排序取最大值
                try
                {
                    HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle, hv_Smooth, hv_AmpThreshold,
              hv_Transition, "all", out hv_Row_Measure, out hv_Col_Measure, out hv_Amplitude_Measure,
              out hv_Distance_Measure);
                }
                catch (HalconException e)
                {
                    int error = e.GetErrorNumber();
                    if (error < 0)
                        throw e;
                }
                try
                {
                    HOperatorSet.TupleLength(hv_Row_Measure, out hv_num);
                }
                catch (HalconException e)
                {
                    int error = e.GetErrorNumber();
                    if (error < 0)
                        throw e;
                }
                if ((int)(new HTuple(hv_num.TupleGreater(0))) != 0)
                {
                    try
                    {
                        HOperatorSet.TupleSortIndex(hv_Amplitude_Measure, out hv_Indices);
                    }
                    catch (HalconException e)
                    {
                        int error = e.GetErrorNumber();
                        if (error < 0)
                            throw e;
                    }
                    hv_index = hv_Indices.TupleSelect(hv_num - 1);
                    hv_Row = hv_Row_Measure.TupleSelect(hv_index);
                    hv_Col = hv_Col_Measure.TupleSelect(hv_index);
                }
            }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);

        }
        // (dev_)set_check ("give_error")

        return;
    }

    public void dev_disp_message(HTuple hv_String, HTuple hv_CoordSystem, HTuple hv_Row,
        HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
    {


        // Local control variables 

        HTuple hv_WindowHandle = null;

        // Initialize local and output iconic variables 


        //获取当前活动窗口
        hv_WindowHandle = -1;
        if (HDevWindowStack.IsOpen())
        {
            hv_WindowHandle = HDevWindowStack.GetActive();
        }
        if ((int)(new HTuple(hv_WindowHandle.TupleNotEqual(-1))) != 0)
        {
            disp_message(hv_WindowHandle, hv_String, hv_CoordSystem, hv_Row, hv_Column,
                hv_Color, hv_Box);
        }

        return;
    }

    public void CalcRotateCenter(HTuple hv_Row1, HTuple hv_Col1, HTuple hv_Row2, HTuple hv_Col2,
        HTuple hv_Angle, out HTuple hv_RowCenter, out HTuple hv_ColCenter)
    {


        // Local iconic variables 


        // Local control variables 

        HTuple hv_angleTest = null, hv_flag = null;
        HTuple hv_mat0 = null, hv_mat1 = null, hv_RowTrans1 = null;
        HTuple hv_ColTrans1 = null, hv_mat2 = null, hv_RowTrans2 = null;
        HTuple hv_ColTrans2 = null, hv_IsOverlapping = null;

        // Initialize local and output iconic variables 

        try
        {
            //输入两个点及两点之间的旋转角度，求出旋转中心

            //求出等腰三角形的底角A
            hv_angleTest = 180 - (hv_Angle.TupleAbs());
            hv_angleTest = ((hv_angleTest / 2)).TupleRad();

            //确定变换旋转矩阵的旋转方向
            hv_flag = 1;
            if ((int)(new HTuple(hv_Angle.TupleLess(0))) != 0)
            {
                hv_flag = -1;
            }

            //gen_cross_contour_xld (Cross, Row1, Col1, 60, 0.785398)
            //gen_cross_contour_xld (Cross, Row2, Col2, 60, 0.785398)
            //第二点以第一点为中心点旋转A度
            HOperatorSet.HomMat2dIdentity(out hv_mat0);
            HOperatorSet.HomMat2dRotate(hv_mat0, hv_flag * hv_angleTest, hv_Row1, hv_Col1,
                out hv_mat1);

            HOperatorSet.AffineTransPoint2d(hv_mat1, hv_Row2, hv_Col2, out hv_RowTrans1,
                out hv_ColTrans1);

            //gen_cross_contour_xld (Cross1, RowTrans1, ColTrans1, 60, 0.785398)
            //distance_pp (Row1, Col1, Row2, Col2, Distance1)
            //distance_pp (Row1, Col1, RowTrans1, ColTrans1, Distance2)

            //让第一点以第二点反向旋转A度
            HOperatorSet.HomMat2dRotate(hv_mat0, (-hv_flag) * hv_angleTest, hv_Row2, hv_Col2,
                out hv_mat2);
            HOperatorSet.AffineTransPoint2d(hv_mat2, hv_Row1, hv_Col1, out hv_RowTrans2,
                out hv_ColTrans2);

            //gen_cross_contour_xld (Cross1, RowTrans2, ColTrans2, 60, 0.785398)
            //distance_pp (Row2, Col2, Row1, Col1, Distance3)
            //distance_pp (Row2, Col2, RowTrans2, ColTrans2, Distance4)

            //求出两线的交点，即为旋转中心
            HOperatorSet.IntersectionLines(hv_Row1, hv_Col1, hv_RowTrans1, hv_ColTrans1,
                hv_Row2, hv_Col2, hv_RowTrans2, hv_ColTrans2, out hv_RowCenter, out hv_ColCenter,
                out hv_IsOverlapping);

            //gen_cross_contour_xld (Cross2, Row, Column, 60, 0.785398)
            //gen_region_line (RegionLine1, Row, Column, Row1, Col1)
            //gen_region_line (RegionLine1, Row, Column, Row2, Col2)










            return;
        }
        catch (HalconException HDevExpDefaultException)
        {

            throw HDevExpDefaultException;
        }
    }


    public void CalcRotatePoint(HTuple hv_RowCenter, HTuple hv_ColCenter, HTuple hv_RowOld,
        HTuple hv_ColOld, HTuple hv_Angle, out HTuple hv_RowNew, out HTuple hv_ColNew)
    {


        // Local control variables 

        HTuple hv_mat0 = null, hv_mat1 = null;

        // Initialize local and output iconic variables 




        //已知旋转中心点，将要被旋转的点和需要旋转的角度，计算旋转后的点的位置
        HOperatorSet.HomMat2dIdentity(out hv_mat0);
        HOperatorSet.HomMat2dRotate(hv_mat0, hv_Angle.TupleRad(), hv_RowCenter, hv_ColCenter,
            out hv_mat1);
        HOperatorSet.AffineTransPoint2d(hv_mat1, hv_RowOld, hv_ColOld, out hv_RowNew,
            out hv_ColNew);




    }

    // Short Description: 通过输入图像查找模板获取转换的坐标矩阵。
    public void FindTemplete(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_ModelScore, out HTuple hv_FixTool)
    {



        // Local control variables 

        HTuple hv_ModelRow = null, hv_ModelColumn = null;
        HTuple hv_ModelAngle = null, hv_ModelScale = null;

        // Initialize local and output iconic variables 

        hv_FixTool = new HTuple();

        if (hv_WindowHandle == null && HDevWindowStack.IsOpen())
        {
            hv_WindowHandle = HDevWindowStack.GetActive();
        }

        HOperatorSet.FindScaledShapeModel(ho_Image, hv_ModelId, (new HTuple(0)).TupleRad()
            , (new HTuple(360)).TupleRad(), 0.95, 1.05, 0.40, 1, 0.1, "none",
            (new HTuple(5)).TupleConcat(1), 0.75, out hv_ModelRow, out hv_ModelColumn,
            out hv_ModelAngle, out hv_ModelScale, out hv_ModelScore);
        if ((int)(new HTuple((new HTuple(hv_ModelScore.TupleLength())).TupleGreater(0))) != 0)
        {
            //生成座标转换矩阵
            HOperatorSet.VectorAngleToRigid(hv_ModelData.TupleSelect(0), hv_ModelData.TupleSelect(
                1), hv_ModelData.TupleSelect(2), hv_ModelRow, hv_ModelColumn, hv_ModelAngle,
                out hv_FixTool);
            //显示找到的轮廓
            if ((int)(1) != 0)
            {
                dev_display_shape_matching_results(hv_ModelId, "red", hv_ModelRow, hv_ModelColumn,
                    hv_ModelAngle, 1, 1, 0);
                //DetlaAngle := ModelAngle - InitAngle
            }
            //显示模板查找得分信息

            dev_disp_message("Model Score is " + hv_ModelScore, "window", 20, 20, "green",
                "false");

        }
        else
        {
            //ModelScore := []
            dev_disp_message("Model find fail !", "window", 20, 20, "red", "true");
        }

        return;
    }

    public void T_Std(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
    out HTuple hv_TupleResult)
    {
        HTuple timeBegin = null;
        HTuple timeEnd = null;
        HOperatorSet.CountSeconds(out timeBegin);
       hv_TupleResult = new HTuple();
        HTuple hv_Score= null, hv_FixTool=null;
        HTuple hv_RowCenter = new HTuple();
        HTuple hv_ColCenter = new HTuple();
        HTuple hv_Radius = new HTuple();
        HTuple hv_RowBegin = new HTuple();
        HTuple hv_ColBegin = new HTuple();
        HTuple hv_RowEnd = new HTuple();
        HTuple hv_ColEnd = new HTuple();
        HTuple hv_Rows = new HTuple(), hv_Cols = new HTuple(), hv_Direct=new HTuple();
        int i = 1;
        //进行模板查找
        FindTemplete(hv_WindowHandle,ho_Image, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
        if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) == 0)
        {
            //模板查找失败
            hv_TupleResult = -999;
            i++;          
            HOperatorSet.CountSeconds(out timeEnd);
            dev_disp_message( "耗时:"+(timeEnd- timeBegin).TupleString(".3f") + "秒", "window", 20 * i, 20, "green", "false");
            return;
        }
        else
        {
            hv_TupleResult[0] = 1;
            string strAll_step = HOperatorSet_Ex.ReadIniString("pram_all", "all_step：", "", hv_Directory + "/pram_path.ini");
            string[] str_All_Type = strAll_step.Split(',');
            string strPram = null;
            
            foreach(string str in str_All_Type)
            {
              
                HOperatorSet_Ex.Read_SetParm(hv_Directory, str, out strPram,out hv_Rows, out hv_Cols, out hv_Direct);
                HOperatorSet.AffineTransPoint2d(hv_FixTool, hv_Rows,hv_Cols, out hv_Rows, out hv_Cols);
                if (str.Substring(0, 4) == "Circ")
                {
                    i++;
                    HOperatorSet_Ex.Fit_Circle( ho_Image, hv_WindowHandle, strPram, hv_Rows, hv_Cols, hv_Direct,
                        out hv_RowCenter,out hv_ColCenter, out hv_Radius);
                    if((int)(new HTuple((new HTuple(hv_Radius.TupleLength())).TupleGreater(0)))==0)
                    {
                        //Circle 查找失败
                        dev_disp_message(str + "查找失败！" , "window", 20 * i, 20, "red", "false");
                        hv_TupleResult = hv_TupleResult.TupleConcat(-998);
                        hv_TupleResult = hv_TupleResult.TupleConcat(-998);
                        hv_TupleResult = hv_TupleResult.TupleConcat(-998);
                    }
                    else
                    {
                        hv_TupleResult = hv_TupleResult.TupleConcat(hv_RowCenter);
                        hv_TupleResult = hv_TupleResult.TupleConcat(hv_ColCenter);
                        hv_TupleResult = hv_TupleResult.TupleConcat(hv_Radius);
                        dev_disp_message( str+"圆心,半径:" + (hv_RowCenter.TupleString(".3f"))+"," + (hv_ColCenter.TupleString(".3f"))+","+
                            (hv_Radius.TupleString(".3f"))  , "window", 20  * i, 20, "green", "false");
                    }
                }
                if (str.Substring(0, 4) == "Line")
                {
                    i++;
                    HOperatorSet_Ex.Fit_Line( ho_Image, hv_WindowHandle, strPram, hv_Rows, hv_Cols,
                        out hv_RowBegin, out hv_ColBegin, out hv_RowEnd, out hv_ColEnd);
                    if ((int)(new HTuple((new HTuple(hv_ColEnd.TupleLength())).TupleGreater(0))) == 0)
                    {
                        //Line 查找失败
                        dev_disp_message( str + "查找失败！", "window", 20  * i, 20, "red", "false");
                        hv_TupleResult = hv_TupleResult.TupleConcat(-997);
                        hv_TupleResult = hv_TupleResult.TupleConcat(-997);
                        hv_TupleResult = hv_TupleResult.TupleConcat(-997);
                        hv_TupleResult = hv_TupleResult.TupleConcat(-997);
                    }
                    else
                    {
                        hv_TupleResult = hv_TupleResult.TupleConcat(hv_RowBegin);
                        hv_TupleResult = hv_TupleResult.TupleConcat(hv_ColBegin);
                        hv_TupleResult = hv_TupleResult.TupleConcat(hv_RowEnd);
                        hv_TupleResult = hv_TupleResult.TupleConcat(hv_ColEnd);
                        dev_disp_message( str+":" + (hv_RowBegin.TupleString(".3f")) + "," + (hv_ColBegin.TupleString(".3f")) + "," +
                            (hv_RowEnd.TupleString(".3f")) +","+ (hv_ColEnd.TupleString(".3f")), "window", 20 * i, 20, "green", "false");
                    }
                }
            }
        }
        i++;
        HOperatorSet.CountSeconds(out timeEnd);
        dev_disp_message("耗时:" + (timeEnd - timeBegin).TupleString(".3f") + "秒", "window", 20 * i, 20, "green", "false");
    }
  // Local procedures 
  // Short Description: 图像处理过程。
    public void T1_1 (HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData, 
      out HTuple hv_TupleResult)
  {



        // Local iconic variables 

        HObject ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_Radius = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            hv_TupleResult = -999;

            if (hv_WindowHandle == null && HDevWindowStack.IsOpen())
            {
                hv_WindowHandle = HDevWindowStack.GetActive();
            }


            //进行模板查找
            FindTemplete(hv_WindowHandle,ho_Image, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {

                //读取第一个ROI,圆环
                ReadRoiAnnularCircle(hv_Directory + "/Circle.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找圆,方向outer指定由外向内,以大圆半径为中心,100个点,可排除20个干扰点,阈值5,
                //平滑系数0.4, 由白到黑,取第一点
                FindCircle(hv_WindowHandle,ho_Image, hv_RoiDataOut, "inner", 100, 20, 18, 1, "positive",
                    "first", out hv_Row, out hv_Col, out hv_Radius);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -998;
                    ho_Cross.Dispose();

                    return;
                }
                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                }
                dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                dev_disp_message("Radius= " + hv_Radius, "window", 80, 20, "green", "false");

                hv_TupleResult = new HTuple();
                hv_TupleResult[0] = 1;
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                //
                //读取第二个ROI,旋转矩形,带方向角度
                HTuple hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1, hv_Angle;

                ReadRoiRectangle2(hv_Directory + "/line.roi", out hv_RoiDataIn);

                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(hv_WindowHandle,ho_Image, hv_RoiDataOut, 100, 20, 20, 10, 0.4, "positive", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                HOperatorSet.AngleLx(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    ho_Cross.Dispose();

                    return;
                }


                dev_disp_message("Angle= " + hv_Angle, "window", 100, 20, "green", "false");

                hv_TupleResult[0] = 1;
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);

            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_Cross.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T2(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_Radius = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            //先赋值，以免发生异常后读取非法内存
            hv_TupleResult = -999;

            if (hv_WindowHandle == null && HDevWindowStack.IsOpen())
            {
                hv_WindowHandle = HDevWindowStack.GetActive();
            }

            FindTemplete(hv_WindowHandle,ho_Image, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,圆环
                ReadRoiAnnularCircle(hv_Directory + "/Circle.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找圆,方向outer指定由外向内,以大圆半径为中心,100个点,可排除20个干扰点,阈值5,
                //平滑系数0.4, 由白到黑,取第一点
                FindCircle(hv_WindowHandle,ho_Image, hv_RoiDataOut, "inner", 100, 20, 5, 0.4, "positive",
                    "first", out hv_Row, out hv_Col, out hv_Radius);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -998;
                    ho_Cross.Dispose();

                    return;
                }

                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                }
                dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                dev_disp_message("Radius= " + hv_Radius, "window", 80, 20, "green", "false");

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/line.roi", out hv_RoiDataIn);

                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(hv_WindowHandle,ho_Image, hv_RoiDataOut, 60, 20, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                HOperatorSet.AngleLx(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    ho_Cross.Dispose();

                    return;
                }


                dev_disp_message("Angle= " + hv_Angle, "window", 100, 20, "green", "false");

                hv_TupleResult = new HTuple();
                hv_TupleResult[0] = 1;
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);

            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;

            }
            ho_Cross.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T3(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_Radius = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            //先赋值，以免发生异常后读取非法内存
            hv_TupleResult = -999;

            if (hv_WindowHandle == null && HDevWindowStack.IsOpen())
            {
                hv_WindowHandle = HDevWindowStack.GetActive();
            }

            FindTemplete(hv_WindowHandle,ho_Image, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,圆环
                ReadRoiAnnularCircle(hv_Directory + "/Circle.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找圆,方向outer指定由外向内,以大圆半径为中心,100个点,可排除20个干扰点,阈值5,
                //平滑系数0.4, 由白到黑,取第一点
                FindCircle(hv_WindowHandle,ho_Image, hv_RoiDataOut, "inner", 100, 20, 15, 0.4, "negative",
                    "first", out hv_Row, out hv_Col, out hv_Radius);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -998;
                    ho_Cross.Dispose();

                    return;
                }

                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                }
                dev_disp_message("row= " + hv_Row, "window", 40, 20, "green", "false");
                dev_disp_message("col= " + hv_Col, "window", 60, 20, "green", "false");

                dev_disp_message("Radius= " + hv_Radius, "window", 80, 20, "green", "false");

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/line.roi", out hv_RoiDataIn);

                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(hv_WindowHandle,ho_Image, hv_RoiDataOut, 60, 20, 20, 10, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = new HTuple();
                    hv_TupleResult[0] = 1;
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                    hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                    hv_TupleResult = hv_TupleResult.TupleConcat(90);
                    ho_Cross.Dispose();

                    return;
                }
                HOperatorSet.AngleLx(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();


                dev_disp_message("Angle= " + hv_Angle, "window", 100, 20, "green", "false");

                hv_TupleResult = new HTuple();
                hv_TupleResult[0] = 1;
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);

            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;

            }
            ho_Cross.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T4(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple(), hv_Row = new HTuple();
        HTuple hv_Col = new HTuple(), hv_Radius = new HTuple();
        HTuple hv_Radius2 = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            //先赋值，以免发生异常后读取非法内存
            hv_TupleResult = -999;

            if (hv_WindowHandle == null && HDevWindowStack.IsOpen())
            {
                hv_WindowHandle = HDevWindowStack.GetActive();
            }

            FindTemplete(hv_WindowHandle,ho_Image, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/line.roi", out hv_RoiDataIn);

                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(hv_WindowHandle,ho_Image, hv_RoiDataOut, 60, 20, 20, 8, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                HOperatorSet.AngleLx(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    ho_Cross.Dispose();

                    return;
                }



                //读取第一个ROI,圆环
                ReadRoiAnnularCircle(hv_Directory + "/Circle.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找圆,方向outer指定由外向内,以大圆半径为中心,100个点,可排除20个干扰点,阈值5,
                //平滑系数0.4, 由白到黑,取第一点
                FindCircle(hv_WindowHandle,ho_Image, hv_RoiDataOut, "outer", 100, 20, 15, 0.4, "negative",
                    "first", out hv_Row, out hv_Col, out hv_Radius);


                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {

                    if (hv_RoiDataOut == null)
                        hv_RoiDataOut = new HTuple();
                    hv_RoiDataOut[2] = (hv_RoiDataOut.TupleSelect(2)) - 15;
                    if (hv_RoiDataOut == null)
                        hv_RoiDataOut = new HTuple();
                    hv_RoiDataOut[5] = (hv_RoiDataOut.TupleSelect(5)) - 45;

                    FindCircle(hv_WindowHandle,ho_Image, hv_RoiDataOut, "inner", 100, 20, 5, 0.4, "positive",
                        "first", out hv_Row, out hv_Col, out hv_Radius2);

                    if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                    {
                        hv_TupleResult = -998;
                        ho_Cross.Dispose();

                        return;
                    }
                }



                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0);
                if (hv_WindowHandle != null)
                {
                    HOperatorSet.DispObj(ho_Cross, hv_WindowHandle);
                }
                dev_disp_message("row= " + hv_Row, "window", 40, 20, "green", "false");
                dev_disp_message("col= " + hv_Col, "window", 60, 20, "green", "false");
                dev_disp_message("Radius= " + hv_Radius, "window", 80, 20, "green", "false");

                dev_disp_message("Angle= " + hv_Angle, "window", 100, 20, "green", "false");

                hv_TupleResult = new HTuple();
                hv_TupleResult[0] = 1;
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);

            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;

            }
            ho_Cross.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T5(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_Radius = new HTuple();
        HTuple hv_RowBegin1 = new HTuple(), hv_ColBegin1 = new HTuple();
        HTuple hv_RowEnd1 = new HTuple(), hv_ColEnd1 = new HTuple();
        HTuple hv_Angle = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            //先赋值，以免发生异常后读取非法内存
            hv_TupleResult = -999;

            if (hv_WindowHandle == null && HDevWindowStack.IsOpen())
            {
                hv_WindowHandle = HDevWindowStack.GetActive();
            }

            FindTemplete(hv_WindowHandle,ho_Image, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,圆环
                ReadRoiAnnularCircle(hv_Directory + "/Circle.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找圆,方向outer指定由外向内,以大圆半径为中心,100个点,可排除20个干扰点,阈值5,
                //平滑系数0.4, 由白到黑,取第一点
                FindCircle(hv_WindowHandle,ho_Image, hv_RoiDataOut, "outer", 100, 20, 12, 0.4, "negative",
                    "first", out hv_Row, out hv_Col, out hv_Radius);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -998;
                    ho_Cross.Dispose();

                    return;
                }

                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0);
                if (hv_WindowHandle != null)
                {
                    HOperatorSet.DispObj(ho_Cross, hv_WindowHandle);
                }
                dev_disp_message("row= " + hv_Row, "window", 40, 20, "green", "false");
                dev_disp_message("col= " + hv_Col, "window", 60, 20, "green", "false");
                dev_disp_message("Radius= " + hv_Radius, "window", 80, 20, "green", "false");

                //读取第二个ROI,旋转矩形,带方向角度
                ReadRoiRectangle2(hv_Directory + "/line.roi", out hv_RoiDataIn);

                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找直线,位置由旋转矩形来确定,方向由ROI旋转矩形确定,100个点,
                //阈值15,平滑系数0.4, 由黑到白,取第一个边缘点
                FindLine(hv_WindowHandle,ho_Image, hv_RoiDataOut, 60, 20, 30, 20, 0.4, "negative", "first",
                    out hv_RowBegin1, out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1);
                HOperatorSet.AngleLx(hv_RowBegin1, hv_ColBegin1, hv_RowEnd1, hv_ColEnd1,
                    out hv_Angle);
                hv_Angle = hv_Angle.TupleDeg();
                if ((int)(new HTuple((new HTuple(hv_RowBegin1.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_TupleResult = -997;
                    ho_Cross.Dispose();

                    return;
                }



                dev_disp_message("Angle= " + hv_Angle, "window", 100, 20, "green", "false");

                hv_TupleResult = new HTuple();
                hv_TupleResult[0] = 1;
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Angle);

            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;

            }
            ho_Cross.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Short Description: 图像处理过程。
    public void T2_1(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_Cross = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_Radius = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Cross);

        try
        {
            //先赋值，以免发生异常后读取非法内存
            hv_TupleResult = -999;

            if (hv_WindowHandle == null && HDevWindowStack.IsOpen())
            {
                hv_WindowHandle = HDevWindowStack.GetActive();
            }

            FindTemplete(hv_WindowHandle,ho_Image, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {
                //读取第一个ROI,圆环
                ReadRoiAnnularCircle(hv_Directory + "/Circle.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找圆,方向outer指定由外向内,以大圆半径为中心,100个点,可排除20个干扰点,阈值5,
                //平滑系数0.4, 由白到黑,取第一点
                FindCircle(hv_WindowHandle,ho_Image, hv_RoiDataOut, "outer", 100, 20, 10, 0.4, "negative",
                    "first", out hv_Row, out hv_Col, out hv_Radius);

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -998;
                    ho_Cross.Dispose();

                    return;
                }

                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0);
                if (hv_WindowHandle != null)
                {
                    HOperatorSet.DispObj(ho_Cross, hv_WindowHandle);
                }
                dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                dev_disp_message("Radius= " + hv_Radius, "window", 80, 20, "green", "false");



                hv_TupleResult = new HTuple();
                hv_TupleResult[0] = 1;
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Radius);

            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;

            }
            ho_Cross.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Cross.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void FindTemplete_Angle(HObject ho_Image, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_ModelScore, out HTuple hv_FixTool)
    {



        // Local control variables 

        HTuple hv_ModelRow = null, hv_ModelColumn = null;
        HTuple hv_ModelAngle = null, hv_ModelScale = null;

        // Initialize local and output iconic variables 

        hv_FixTool = new HTuple();


        HOperatorSet.FindScaledShapeModel(ho_Image, hv_ModelId, (new HTuple(0)).TupleRad()
            , (new HTuple(360)).TupleRad(), 0.95, 1.05, 0.20, 1, 0.5, "least_squares",
            (new HTuple(5)).TupleConcat(1), 0.75, out hv_ModelRow, out hv_ModelColumn,
            out hv_ModelAngle, out hv_ModelScale, out hv_ModelScore);

        if ((int)(new HTuple((new HTuple(hv_ModelScore.TupleLength())).TupleGreater(0))) != 0)
        {
            //生成座标转换矩阵
            HOperatorSet.VectorAngleToRigid(hv_ModelData.TupleSelect(0), hv_ModelData.TupleSelect(
                1), hv_ModelData.TupleSelect(2), hv_ModelRow, hv_ModelColumn, hv_ModelAngle,
                out hv_FixTool);
            //显示找到的轮廓
            if ((int)(0) != 0)
            {
                dev_display_shape_matching_results(hv_ModelId, "red", hv_ModelRow, hv_ModelColumn,
                    hv_ModelAngle, 1, 1, 0);
                //DetlaAngle := ModelAngle - InitAngle
            }
            //显示模板查找得分信息

            dev_disp_message("Model Score is " + hv_ModelScore, "window", 20, 20, "green",
                "false");

        }
        else
        {
            //ModelScore := []
            dev_disp_message("Model find fail !", "window", 20, 20, "red", "true");
        }

        return;



        return;
    }

    // Short Description: 图像处理过程。
    public void T1(HTuple hv_WindowHandle, HObject ho_Image, HTuple hv_Directory, HTuple hv_ModelId, HTuple hv_ModelData,
        out HTuple hv_TupleResult)
    {



        // Local iconic variables 

        HObject ho_Cross = null, ho_circle1 = null, ho_circle2 = null;
        HObject ho_RegionDifference = null, ho_ImageReduced = null;
        HObject ho_Region1 = null, ho_Arrow = null;


        // Local control variables 

        HTuple hv_Score = null, hv_FixTool = null;
        HTuple hv_RoiDataIn = new HTuple(), hv_RoiDataOut = new HTuple();
        HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_Radius = new HTuple();
        HTuple hv_Value = new HTuple(), hv_Row2 = new HTuple();
        HTuple hv_Column2 = new HTuple(), hv_Phi = new HTuple();
        HTuple hv_Length1 = new HTuple(), hv_Length2 = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Cross);
        HOperatorSet.GenEmptyObj(out ho_circle1);
        HOperatorSet.GenEmptyObj(out ho_circle2);
        HOperatorSet.GenEmptyObj(out ho_RegionDifference);
        HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        HOperatorSet.GenEmptyObj(out ho_Region1);
        HOperatorSet.GenEmptyObj(out ho_Arrow);

        try
        {
            hv_TupleResult = -999;

            if (hv_WindowHandle == null && HDevWindowStack.IsOpen())
            {
                hv_WindowHandle = HDevWindowStack.GetActive();
            }

            //进行模板查找
            FindTemplete(hv_WindowHandle,ho_Image, hv_ModelId, hv_ModelData, out hv_Score, out hv_FixTool);
            if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
            {

                //读取第一个ROI,圆环
                ReadRoiAnnularCircle(hv_Directory + "/Circle.roi", out hv_RoiDataIn);
                //根据模板查找的座标来转换ROI
                TranslateRoi(hv_FixTool, hv_RoiDataIn, out hv_RoiDataOut);
                //查找圆,方向outer指定由外向内,以大圆半径为中心,100个点,可排除20个干扰点,阈值5,
                //平滑系数0.4, 由白到黑,取第一点
                FindCircle(hv_WindowHandle,ho_Image, hv_RoiDataOut, "outer", 100, 20, 5, 0.4, "negative",
                    "first", out hv_Row, out hv_Col, out hv_Radius);
                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                if (hv_WindowHandle != null)
                {
                    HOperatorSet.DispObj(ho_Cross, hv_WindowHandle);
                }

                if ((int)(new HTuple((new HTuple(hv_Row.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_TupleResult = -998;
                    ho_Cross.Dispose();
                    ho_circle1.Dispose();
                    ho_circle2.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Region1.Dispose();
                    ho_Arrow.Dispose();

                    return;
                }
                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Col, 60, 0.785398);
                if (hv_WindowHandle != null)
                {
                    HOperatorSet.DispObj(ho_Cross, hv_WindowHandle);
                }
                dev_disp_message("Row= " + hv_Row, "window", 40, 20, "green", "false");
                dev_disp_message("Col= " + hv_Col, "window", 60, 20, "green", "false");
                dev_disp_message("Radius= " + hv_Radius, "window", 80, 20, "green", "false");

                ho_circle1.Dispose();
                HOperatorSet.GenCircle(out ho_circle1, hv_Row, hv_Col, hv_Radius - 40);
                ho_circle2.Dispose();
                HOperatorSet.GenCircle(out ho_circle2, hv_Row, hv_Col, hv_Radius - 130);

                ho_RegionDifference.Dispose();
                HOperatorSet.Difference(ho_circle1, ho_circle2, out ho_RegionDifference);
                ho_ImageReduced.Dispose();
                HOperatorSet.ReduceDomain(ho_Image, ho_RegionDifference, out ho_ImageReduced
                    );
                //mean_image (ImageReduced, ImageMean3, 9, 9)
                //emphasize (ImageReduced, ImageEmphasize, 7, 7, 1)

                HOperatorSet.GrayFeatures(ho_RegionDifference, ho_ImageReduced, "mean", out hv_Value);
                //edges_image (ImageEmphasize, ImaAmp, ImaDir, 'canny', 1, 'nms', 8, 30)
                //edges_sub_pix (ImageEmphasize, Edges1, 'canny', 1, 8, 20)
                //gray_histo (RegionDifference, ImageEmphasize, AbsoluteHisto1, RelativeHisto1)
                //gray := 250
                //if (Value > 250)
                //Value := 250
                //endif
                ho_Region1.Dispose();
                HOperatorSet.Threshold(ho_ImageReduced, out ho_Region1, 180, 255);

                //opening_circle (Region1, RegionClosing, 1.5)
                //connection (RegionClosing, ConnectedRegions)
                //select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 4000, 6500)
                //select_shape (SelectedRegions, SelectedRegions2, 'rect2_len1', 'and', 160, 210)
                //gray_features (SelectedRegions2, ImageReduced, 'mean', Value)

                HOperatorSet.SmallestRectangle2(ho_Region1, out hv_Row2, out hv_Column2,
                    out hv_Phi, out hv_Length1, out hv_Length2);
                hv_Phi = hv_Phi + (3.1415926 / 2);
                ho_Arrow.Dispose();
                gen_arrow_contour_xld(out ho_Arrow, hv_Row, hv_Col, hv_Row - (hv_Radius * (hv_Phi.TupleSin()
                    )), hv_Col + (hv_Radius * (hv_Phi.TupleCos())), 5, 5);
                if (hv_WindowHandle != null)
                {
                    HOperatorSet.DispObj(ho_Arrow, hv_WindowHandle);
                }

                hv_Phi = hv_Phi.TupleDeg();
                if ((int)(new HTuple(hv_Phi.TupleGreater(180))) != 0)
                {
                    hv_Phi = hv_Phi - 180;
                }
                dev_disp_message("Phi= " + hv_Phi, "window", 100, 20, "green", "false");
                dev_disp_message("Length1= " + hv_Length1, "window", 120, 20, "green", "false");
                dev_disp_message("Length2= " + hv_Length2, "window", 140, 20, "green", "false");
                //if (|Value| ==0)
                //TupleResult := -997
                //return ()
                //endif

                hv_TupleResult = new HTuple();
                hv_TupleResult[0] = 1;
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Row);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Col);
                hv_TupleResult = hv_TupleResult.TupleConcat(hv_Phi);

            }
            else
            {
                //模板查找失败
                hv_TupleResult = -999;
            }

            ho_Cross.Dispose();
            ho_circle1.Dispose();
            ho_circle2.Dispose();
            ho_RegionDifference.Dispose();
            ho_ImageReduced.Dispose();
            ho_Region1.Dispose();
            ho_Arrow.Dispose();

            return;

        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Cross.Dispose();
            ho_circle1.Dispose();
            ho_circle2.Dispose();
            ho_RegionDifference.Dispose();
            ho_ImageReduced.Dispose();
            ho_Region1.Dispose();
            ho_Arrow.Dispose();

            throw HDevExpDefaultException;
        }
    }

    // Main procedure 
    private void action()
    {

        // Local iconic variables 

        HObject ho_Image = null;


        // Local control variables 

        HTuple hv_window = null, hv_nSelect = null;
        HTuple hv_Product = null, hv_dir = null, hv_ModelId = null;
        HTuple hv_ModelData = null, hv_nTotal = null, hv_nFailCount = null;
        HTuple hv_dirTest = null, hv_ImageFiles = null, hv_Index = null;
        HTuple hv_TupleResult = new HTuple();

        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Image);

        try
        {

            HOperatorSet.SetWindowAttr("background_color", "black");
            HOperatorSet.OpenWindow(0, 0, 800, 640, 0, "", "", out hv_window);
            HDevWindowStack.Push(hv_window);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }
            hv_nSelect = "T1_1";
            hv_Product = "RCam";
            hv_dir = "F:/Ver C/AutoFrame/Exe/VisionConfig/";
            hv_dir = ((hv_dir + hv_Product) + "/") + hv_nSelect;

            InitTemplete(null,hv_dir, out hv_ModelId, out hv_ModelData);

            hv_nTotal = 0;
            hv_nFailCount = 0;

            hv_dirTest = "D:/exe/Image/RawImage/20170901/T5_ok";
            //dirTest := 'D:/test'
            HOperatorSet.ListFiles(hv_dir, ((new HTuple("files")).TupleConcat("recursive")).TupleConcat(
                "follow_links"), out hv_ImageFiles);
            HOperatorSet.TupleRegexpSelect(hv_ImageFiles, (new HTuple("\\.(tif|tiff|gif|bmp|jpg|jpeg|                       jp2|png|pcx|pgm|ppm|pbm|xwd|ima)$")).TupleConcat(
                "ignore_case"), out hv_ImageFiles);
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ImageFiles.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                ho_Image.Dispose();
                HOperatorSet.ReadImage(out ho_Image, hv_ImageFiles.TupleSelect(hv_Index));
                //Image Acquisition 02: Code generated by Image Acquisition 02
                //open_framegrabber ('GigEVision', 0, 0, 0, 0, 0, 0, 'progressive', -1, 'default', -1, 'false', 'default', 'Cam_4', 0, -1, AcqHandle)
                //while (true)
                //grab_image (Image, AcqHandle)
                //Image Acquisition 02: Do something


                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                }
                if ((int)(new HTuple(hv_nSelect.TupleEqual("T1"))) != 0)
                {
                    //首先通过模板查找及圆拟合获得产品的中心点和座标变换工具
                    //dir := 'F:/FPC Coating/AutoFrame/Exe/VisionConfig/'
                    //dir := dir + Product +'/'+ nSelect
                    T1(null,ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T1_1"))) != 0)
                {
                    T1_1(null, ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);

                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T2_1"))) != 0)
                {
                    T2_1(null, ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);

                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T2"))) != 0)
                {
                    T2(null, ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                    //CalcRotatePoint (1, 1, 2, 2, 3, rr, cc)
                    //CalcRotateCenter (1, 1, 2, 2, 3, rr, cc)
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T3"))) != 0)
                {
                    T3(null, ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T4"))) != 0)
                {
                    T4(null, ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);
                }
                else if ((int)(new HTuple(hv_nSelect.TupleEqual("T5"))) != 0)
                {
                    T5(null, ho_Image, hv_dir, hv_ModelId, hv_ModelData, out hv_TupleResult);

                }
                dev_disp_message("ret = " + (hv_TupleResult.TupleSelect(0)), "window", 200,
                    20, "red", "true");
                //stop ()
                //endwhile
                //close_framegrabber (AcqHandle)
                if ((int)(new HTuple((new HTuple(hv_TupleResult.TupleLength())).TupleLess(
                    2))) != 0)
                {
                    //write_image (Image, 'bmp', 0, 'd:/test/'+ Index)
                }
                //wait_seconds (0.1)
            }
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Image.Dispose();

            throw HDevExpDefaultException;
        }
        ho_Image.Dispose();

    }


}
#if !NO_EXPORT_APP_MAIN
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

